\chapter{Desarrollo software del manipulador}
\label{cap:capitulo6}

\vspace{1cm}

En este capítulo se aborda el desarrollo software necesario para poder controlar el hardware creado en el capítulo anterior. Para ello 
se hace uso de las herramientas mencionadas en \ref{sec:software}.

Poner fotito UML 

\section{Control de los actuadores}
En robótica, los actuadores son los componentes responsables de convertir las señales eléctricas en movimiento físico. 

\subsection{Control de motores paso a paso}
\label{subsec:control_pap}
hablar de gbl y lo q simplifica esto
del controlador hardware utilizado y que realizxa por debajo

Basado en paralelos

\section{Comunicación ordenador $\leftrightarrows$ robot}
En esta sección se exponen los mecanismos necesarios para permitir la comunicación entre el ordenador y el microcontrolador 
integrado en la base del robot, así como, la arquitectura del sistema robótico. Además se detallan las configuraciones necesarias 
para adaptar al mundo de la robótica las diferentes partes que lo componen.

\subsection{Interfaces de comunicación de la placa MKS DLC32\ref{sec:mksdlc32}}
En base a las especificaciones del manual\footnote{\url{https://raw.githubusercontent.com/makerbase-mks/MKS-DLC32/main/doc/DLC32\%20wiring\%20manual.pdf}} 
de la placa, permite establecer comunicaciones via USB y existe la posibilidad (reside en el propio firmware) de utilizar la funcionalidad 
Wi-Fi del ESP32. 
La comunicación obtenida mediante el uso del puerto USB se realiza sobre el protocolo \ac{UART}. Este protocolo serie es utilizado para 
transmitir datos de forma asíncrona entre dispositivos. Es comúnmente usado en la interconexión de microcontroladores, 
periféricos y otros componentes electrónicos. El UART convierte los datos paralelos en datos serie y viceversa, utilizando bits 
de inicio, datos, bits de parada y posiblemente bits de paridad para la sincronización y detección de errores. 
\begin{figure} [h!]
    \begin{center}
    \includegraphics[width=12cm]{figs/uart.png}
    \end{center}
    \caption{Diagramas de tiempo de UART}
    \label{fig:uart}
\end{figure}\ 
Otra forma de comunicarnos con la placa es mediante el uso del su adaptador inalámbrico Wi-Fi. Existen firmwares, como es el caso de 
Grbl, que tienen una versión adaptada para microcontroladores con conectividad Wi-Fi que permiten enviar comandos usando una gran 
variedad de protocolos convencionales usados en redes de ordenadores. En este caso, Telnet. 

Además, el firmware de Grbl es capaz de levantar un punto de acceso inalámbrico al cual puedes conectarte como si de un router 
se tratara y se puede acceder a un servidor alojado en su dirección IP. Para acceder a él, basta con introducir 192.168.1.1 en la 
barra superior del navegador web para acceder a una interfaz de usuario que permite controlar los movimientos de la máquina. En este 
caso tiene un aspecto peculiar y no amigable con el mundo de la robótica ya que está pensado para el uso en CNC. Es por esto que es 
necesario realizar unas ciertas configuraciones para su uso en robótica.

grbl wifi
grbl cable
biblioteca python usada
detalles de la comunicacion via codigo G
ejemplos de uso ugs 


\subsection{Adaptación de grbl para su uso en robótica}
GRBL tiene ciertas limitaciones a la hora de su utilización en robótica. Es normal, debido a que está pensado para controlar máquinas 
\acs{CNC} de 3 ejes prismáticos. Pese a esto, se pueden hacer ciertas modificaciones para adaptarlo a esta aplicación. 

\subsubsection{Parámetros de Grbl}
Para acceder y modificar los parámetros de Grbl se deben realizar los siguientes pasos:
\begin{enumerate}
\item Debemos tener conectada al ordenador la placa con el firmware de Grbl instalado.
\item Podemos usar un programa especializado con interfaz gráfica como \ac{UGS} o mediante una terminal serial, como puede ser Cutecom.
\item Introducimos la velocidad de trasmisión de Grbl por defecto; 115200 baudios. 
\item Para preguntar al firmware sobre los parámetros que hay configurados, introducimos los caracteres: \$\$
\item Para modificar un parámetro, introducimos un texto del estilo: \$número=nuevoValor
\end{enumerate}

Para su uso en robótica nos interesa modificar los siguientes parámetros: 
\begin{itemize}
\item \textbf{\$1}: Retardo o tiempo de espera entre pulsos de paso cuando el motor está inactivo (en milisegundos). Debemos configurar 
este parámetro en su valor máximo, en este caso 255. Este valor tiene un significado especial, haciendo que los motores paso a paso 
se mantendrán energizados constantemente aunque no se estén moviendo. Es de vital importancia para evitar que el brazo se desplome tras terminar un cierto movimiento.  
\item \textbf{\$100}, \textbf{\$101} y \textbf{\$102}: Indican el número de pasos por unidad de movimiento para los ejes X, Y, Z respectivamente. 
\\Por defecto está pensado para utilizar pasos por milímetro. Como se pretende utilizar articulaciones de rotación, debemos expresar esta relación 
en función de alguna medida angular. La unidad a utilizar podría ser: grados, radianes o vueltas, entre otras. En este trabajo se 
utilizan los grados debido a que en radianes y vueltas la unidad correspondía a un gran número de pasos y era dificil controlar la aceleración para incrementos de 
0.1 vueltas. 

\begin{myequation}[h!]
\begin{equation}
    PasosPorGrado = \frac{Microstepping * Ratio}{1.8^\circ}
\nonumber
\label{ec:pasos_por_grado}
\end{equation}
\caption[Cálculo de pasos por grado en Grbl]{Cálculo de pasos por grado en Grbl}
\end{myequation} 

\item \textbf{\$110}, \textbf{\$111} y \textbf{\$112}: Indican la velocida máxima a la que puede moverse cada eje X, Y, Z en "unidades" por segundo. 
En este caso, grados por segundo. Estos valores se deben encontrar por medio de la experimentación. Se trata de una medida de seguridad en 
caso de que el usuario quiera mover demasiado rápido un eje pudiendo dañar el brazo.

\item \textbf{\$120}, \textbf{\$121} y \textbf{\$122}: Indican la aceleración máxima a la que puede moverse cada eje X, Y, Z en "unidades" por segundo cuadrado. 
En este caso, grados por segundo cuadrado. Estos valores tambien se deben encontrar por medio de la experimentación. Se trata de una medida de seguridad en 
caso de que el usuario quiera mover demasiado rápido un eje pudiendo dañar el brazo. Se debe encontrar una aceleración idónea para todos 
los movimientos, una limitación de grbl es que no se puede comandar un movimiento diciendole una determinada aceleración.

\end{itemize}

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Parámetro} & \textbf{Valor} \\
\hline
\$0 & 0 \\
\$1 & 255 \\
\$2 & Bla \\
\$0 & 0 \\
\$0 & 0 \\
\$0 & 0 \\
\$0 & 0 \\

\end{tabular}
\caption{Parámetros Grbl usados en este trabajo}
\label{cuadro:parametros_grbl}
\end{center}
\end{table}

En esta página oficial de documentación se profundiza más en la finalidad de cada parámetro.
Para mas info: https://github.com/gnea/grbl/blob/master/doc/markdown/commands.md

%26.\wideparen{6}\\
Para mas info: https://github.com/gnea/grbl/blob/master/doc/markdown/settings.md

\section{Denavit-Hartenberg}
La representación Denavit-Hartenberg consiste en un procedimieto sistemático para describir la estructura cinemática de una cadena 
articulada constituida por articulaciones con un solo grado de libertad. El procedimiento consiste en los siguientes pasos:
\begin{enumerate}
\item \textbf{Numerar los eslabones:} Empezando nombrando con el \textbf{0} a la base (unida al suelo) y \textbf{1} al siguiente eslabón movil, y así con el resto.
\item \textbf{Numerar las articulaciones:} La articulación \textbf{1} será el primer grado de libertad, y \textbf{n} el último.
\item \textbf{Localizar el eje de cada articulación:} En \textit{joints} de revolución, es el eje de rotación y en los prismáticos será 
el eje por el cual se mueve el eslabón.
\item \textbf{Ejes Z:}
\item \textbf{Sistema de coordenadas 0:}
\item \textbf{Ejes X:}
\item \textbf{Ejes Y:}
\item \textbf{Sistema del extremo del robot:}


\end{enumerate}
Fuente: https://www.ciencia-explicada.com/2013/02/parametrizacion-denavit-hartenberg-para.html

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Trasformación} & \textbf{$\theta$} & \textbf{d} & \textbf{a} & \textbf{$\alpha$}\\
\hline
0$\rightarrow$1 & L1 & 170mm & a & a \\
\hline
\end{tabular}
\caption{Tabla resultante de Denavit-Hartenberg}
\label{cuadro:tablaDH}
\end{center}
\end{table}


\section{Integración con ROS 2}
En esta sección se detalla el proceso de integración del robot G-Arm en \acs{ROS}.

\subsection{Descripción del robot}
\begin{enumerate}
    \item Creamos una carpeta que será nuestro workspace:
    \begin{verbatim}
        cd && mkdir workspace
    \end{verbatim}
    
    \item Creamos una carpeta src dentro de la carpeta anterior:
    \begin{verbatim}
        cd workspace && mkdir src
    \end{verbatim}
    
    \item Dentro de la carpeta src creamos el paquete con:
    
    \begin{verbatim}
        ros2 pkg create --build-type ament_cmake g_arm_description
    \end{verbatim}
    
    \item Dentro de la carpeta g\_arm\_description, creamos una serie de carpetas con:
    \begin{verbatim}
        mkdir launch rviz urdf meshes
    \end{verbatim}
    
    \item Podemos borrar la carpeta src que hay dentro de nuestro paquete ya que no es necesaria en la descripción del robot:
    \begin{verbatim}
        rm -r src
    \end{verbatim}
    
    \item Añadimos al fichero \textit{package.xml}, entre  
    %<buildtool_depend>ament_cmake</buildtool_depend> y <test_depend>ament_lint_auto</test_depend>
    \lstset{
        language=XML, % Establece el lenguaje como XML
        basicstyle=\ttfamily, % Fuente monoespaciada
        keywordstyle=\bfseries\color{blue}, % Estilo de las palabras clave
        commentstyle=\itshape\color{gray}, % Estilo de los comentarios
        stringstyle=\color{orange}, % Estilo de las cadenas de texto
        showstringspaces=false, % No mostrar espacios en cadenas de texto
        breaklines=true, % Dividir líneas largas
        frame=lines, % Agregar un marco alrededor del código
        numbers=left, % Mostrar números de línea
        numberstyle=\tiny\color{gray}, % Estilo de los números de línea
        captionpos=b % Posición de la leyenda del código (abajo)
    }
    
    \begin{lstlisting}
        <exec_depend>joint_state_publisher</exec_depend>
        <exec_depend>robot_state_publisher</exec_depend>
        <exec_depend>rviz</exec_depend>
        <exec_depend>xacro</exec_depend>
    \end{lstlisting}
    
    
    
    %%entre <buildtool_depend>ament_cmake</buildtool_depend> y  <test_depend>ament_lint_auto</test_depend>
    
    \item Compilamos el paquete desde la carpeta workspace:
    
    \begin{verbatim}
        colcon build --symlink-install
    \end{verbatim}
    
    \item Añadimos esto al final del .bashrc:
    \begin{verbatim}
        source ~/workspace/install/local_setup.bash
    \end{verbatim}
    
    \end{enumerate}
\subsubsection{Creación del paquete de descripción}

\subsubsection{Describir un robot mediante \ac{URDF} y Xacro}
Es un formato de archivo cuyo propósito es describir la estructura, cinemática y aspecto de un robot.  
Se trata de un estándar ampliamente utilizado en la comunidad de robótica, especialmente en \ac{ROS}.

En un archivo URDF, se especifica la geometría del robot mediante la definición de partes (links) y articulaciones (joints). 
Cada parte se describe mediante su forma y tamaño, mientras que las articulaciones definen las restricciones de movimiento y las relaciones entre los enlaces.
Además de esto, un archivo URDF también puede incluir información sobre la masa y la inercia de los enlaces, así como como texturas y modelos 3D.

El formato URDF se basa en el lenguaje \ac{XML}, lo que permite describir el robot de una forma estructurada y legible. Con la descripción 
en URDF, los robots pueden ser simulados, visualizados y controlados.

Para crear un paquete para describir un robot en ros2 debemos de seguir el siguiente procedimiento:



poner un tree para ver como queda todo 
hablar de urdf y xacro
hablar de rviz y controladores



\subsection{Nodos}


\newpage
\section{Integración en MoveIt 2}
\noindent Con el fin de sacar el máximo partido de este robot, es necesario implementarlo también en MoveIt.
hablar setup assistant y particularidades urdf pa que vaya

Primero de todo, debemos tener instalado MoveIt 2. Para ello se debe seguir el proceso de 
instalación\footnote{\url{https://moveit.picknik.ai/main/doc/tutorials/getting_started/getting_started.html}} de la documentación.

Para crear el paquete de MoveIt de G-Arm, se ha seguido los siguientes pasos:
\begin{enumerate}
\item Lanzamos el asistente de configuración.
\begin{verbatim}
    ros2 launch moveit_setup_assistant setup_assistant.launch.py
\end{verbatim}
\item Pulsamos sobre \textit{"Create New MoveIt Configuration Package"} y cargamos el URDF/Xacro del paquete de descripción 
del robot. Si el fichero es válido, aparecerán una serie de apartados a configuar en el lateral izquierdo del asistente. 
\item Comenzamos configurando \textit{"Self-Collisions"} (Auto colisiones). En este apartado se hace uso de la descripción 
de colisiones del brazo para generar una matriz de posibles colisiones que se pueden dar. Dejando el valor 
por defecto, pulsamos sobre \textit{"Generate Collision Matrix"}.
\item A continuación, configuramos los \textit{"Planning Groups"}. 
\end{enumerate}


\section{Pruebas}
En esta sección se pone a prueba los aspectos técnicos que determinan el desempeño y la fiabilidad del brazo robot. 
características.

\subsection{Estabilidad y vibración}
Este tipo de pruebas determinan como el movimiento del mismo afecta en su estabilidad y estructura. Además se determina el nivel de 
vibraciones no deseadas que puedan afectar su precisión y desempeño.
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Parámetro} & \textbf{Valor} \\
\hline
Capacidad de carga máxima (completamente extendido) & $\pm9mm$\\
Capacidad de carga máxima (medio extendido) & $\pm9mm$\\
Capacidad de carga máxima (contraido) & $\pm9mm$\\
Capacidad de carga máxima (operativa) & $\pm9mm$\\
\hline
\end{tabular}
\caption{Evaluación de la estabilidad}
\label{cuadro:evaluacion_estabilidad}
\end{center}
\end{table}

\subsection{Capacidad de carga}
En este tipo de pruebas se evalua la capacidad del brazo a la hora de levantar diferentes pesos. De esta manera se puede determinar 
el límite de carga del brazo y verificar si puede manejar objetos de manera segura y eficiente sin perder capacidades.
\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Parámetro} & \textbf{Valor} \\
\hline
Capacidad de carga máxima (completamente extendido) & \SI{10}{\kilo\gram} \\
Capacidad de carga máxima (medio extendido) & \SI{10}{\gram} \\
Capacidad de carga máxima (contraido) & \SI{10}{\gram} \\
Capacidad de carga máxima (operativa) & \SI{10}{\gram} \\
\hline
\end{tabular}
\caption{Evaluación de la capacidad de carga}
\label{cuadro:evaluacion_carga}
\end{center}
\end{table}

Tablita de como afecta el peso a la precisión y demás

\subsection{Velocidad y tiempo de respuesta}
Es importante realizar este tipo de pruebas para evaluar las distintas velocidades que es capaz de manejar el brazo en la ejecución 
de diferentes movimientos. Además, se puede evaluar la capacidad del brazo para responder rápidamente a comandos y ajustar su 
velocidad rápidamente.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Parámetro} & \textbf{Valor} \\
\hline
Velocidad máxima & \SI{10}{\meter\per\second}\\
Aceleración máxima & \SI{10}{\meter\per\second}\\
Tiempo de respuesta (señal de la herramienta) & \SI{35}{\milli\second} \\
Tiempo de respuesta (movimiento del brazo) & \SI{35}{\milli\second} \\
\hline
\end{tabular}
\caption{Evaluación de la velocidad y tiempo de respuesta}
\label{cuadro:evaluacion_velocidad}
\end{center}
\end{table}

\subsection{Exactitud y repetitividad} 
Se procede a realiza pruebas para evaluar la precisión del brazo robot en la ejecución de movimientos y la repetibilidad 
de estos movimientos. Se mide la desviación del brazo robot en comparación con las coordenadas objetivo y verificar si 
es capaz de alcanzar de manera consistente los mismos puntos en un cierto número de intentos.


